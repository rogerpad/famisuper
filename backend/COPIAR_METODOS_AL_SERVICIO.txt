INSTRUCCIONES PARA COMPLETAR reports.service.ts

1. Abre el archivo: backend/src/modules/reports/reports.service.ts
2. Busca la línea que dice: private async getAgentTypeId(): Promise<number> {
3. JUSTO ANTES de esa línea, pega TODO el siguiente código:

=== INICIO DEL CÓDIGO A COPIAR ===

  // ==================== REPORTES DE OPERACIÓN SUPER ====================

  async getSuperClosingsReport(
    startDate?: string,
    endDate?: string,
    cajaNumero?: number,
    usuarioId?: number,
  ) {
    const whereConditions: any = { activo: true };

    if (startDate && endDate) {
      whereConditions.fechaCierre = Between(new Date(startDate), new Date(endDate));
    }
    if (cajaNumero) whereConditions.cajaNumero = cajaNumero;
    if (usuarioId) whereConditions.usuarioId = usuarioId;

    const cierres = await this.superClosingsRepository.find({
      where: whereConditions,
      relations: ['usuario'],
      order: { fechaCierre: 'DESC' },
    });

    const cierresData = cierres.map(cierre => ({
      id: cierre.id,
      fecha: cierre.fechaCierre,
      usuario: `${cierre.usuario.nombre} ${cierre.usuario.apellido}`,
      cajaNumero: cierre.cajaNumero,
      efectivoInicial: Number(cierre.efectivoInicial),
      efectivoTotal: Number(cierre.efectivoTotal),
      efectivoCierreTurno: Number(cierre.efectivoCierreTurno),
      faltanteSobrante: Number(cierre.faltanteSobrante),
      gastos: Number(cierre.gastos),
    }));

    const totales = {
      totalEfectivoInicial: cierresData.reduce((sum, c) => sum + c.efectivoInicial, 0),
      totalEfectivoFinal: cierresData.reduce((sum, c) => sum + c.efectivoCierreTurno, 0),
      totalGastos: cierresData.reduce((sum, c) => sum + c.gastos, 0),
      totalFaltantes: cierresData.filter(c => c.faltanteSobrante < 0)
        .reduce((sum, c) => sum + Math.abs(c.faltanteSobrante), 0),
      totalSobrantes: cierresData.filter(c => c.faltanteSobrante > 0)
        .reduce((sum, c) => sum + c.faltanteSobrante, 0),
    };

    return { cierres: cierresData, totales };
  }

  async exportSuperClosingsToExcel(
    startDate?: string,
    endDate?: string,
    cajaNumero?: number,
    usuarioId?: number,
  ): Promise<Buffer> {
    const data = await this.getSuperClosingsReport(startDate, endDate, cajaNumero, usuarioId);
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Cierres Super');

    worksheet.columns = [
      { header: 'ID', key: 'id', width: 10 },
      { header: 'Fecha', key: 'fecha', width: 20 },
      { header: 'Usuario', key: 'usuario', width: 25 },
      { header: 'Caja', key: 'cajaNumero', width: 10 },
      { header: 'Efectivo Inicial', key: 'efectivoInicial', width: 18 },
      { header: 'Efectivo Total', key: 'efectivoTotal', width: 18 },
      { header: 'Efectivo Cierre', key: 'efectivoCierreTurno', width: 18 },
      { header: 'Faltante/Sobrante', key: 'faltanteSobrante', width: 18 },
      { header: 'Gastos', key: 'gastos', width: 15 },
    ];

    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF4472C4' },
    };

    data.cierres.forEach(cierre => {
      worksheet.addRow({
        ...cierre,
        fecha: new Date(cierre.fecha).toLocaleString(),
      });
    });

    worksheet.addRow({});
    const totalRow = worksheet.addRow({
      id: '',
      fecha: '',
      usuario: '',
      cajaNumero: 'TOTALES:',
      efectivoInicial: data.totales.totalEfectivoInicial,
      efectivoTotal: '',
      efectivoCierreTurno: data.totales.totalEfectivoFinal,
      faltanteSobrante: '',
      gastos: data.totales.totalGastos,
    });
    totalRow.font = { bold: true };

    for (let i = 2; i <= worksheet.rowCount; i++) {
      ['E', 'F', 'G', 'H', 'I'].forEach(col => {
        const cell = worksheet.getCell(`${col}${i}`);
        if (typeof cell.value === 'number') {
          cell.numFmt = '"L"#,##0.00';
        }
      });
    }

    return await workbook.xlsx.writeBuffer() as Buffer;
  }

  async getSuperExpensesReport(
    startDate?: string,
    endDate?: string,
    tipoEgresoId?: number,
    cajaNumero?: number,
  ) {
    const whereConditions: any = { activo: true };

    if (startDate && endDate) {
      whereConditions.fechaEgreso = Between(new Date(startDate), new Date(endDate));
    }
    if (tipoEgresoId) whereConditions.tipoEgresoId = tipoEgresoId;
    if (cajaNumero) whereConditions.cajaNumero = cajaNumero;

    const egresos = await this.superExpensesRepository.find({
      where: whereConditions,
      relations: ['tipoEgreso', 'formaPago', 'usuario'],
      order: { fechaEgreso: 'DESC', hora: 'DESC' },
    });

    const egresosData = egresos.map(egreso => ({
      id: egreso.id,
      fecha: egreso.fechaEgreso,
      tipoEgreso: egreso.tipoEgreso?.nombre || 'N/A',
      descripcion: egreso.descripcionEgreso || '',
      total: Number(egreso.total),
      formaPago: egreso.formaPago?.nombre || 'N/A',
      usuario: `${egreso.usuario.nombre} ${egreso.usuario.apellido}`,
      cajaNumero: egreso.cajaNumero,
    }));

    const resumenMap = new Map<string, { cantidad: number; total: number }>();
    egresosData.forEach(egreso => {
      if (!resumenMap.has(egreso.tipoEgreso)) {
        resumenMap.set(egreso.tipoEgreso, { cantidad: 0, total: 0 });
      }
      const resumen = resumenMap.get(egreso.tipoEgreso)!;
      resumen.cantidad++;
      resumen.total += egreso.total;
    });

    const resumenPorTipo = Array.from(resumenMap.entries()).map(([tipo, datos]) => ({
      tipo,
      cantidad: datos.cantidad,
      total: datos.total,
    }));

    const totalGeneral = egresosData.reduce((sum, e) => sum + e.total, 0);
    const diasEnRango = startDate && endDate
      ? Math.max(1, Math.ceil((new Date(endDate).getTime() - new Date(startDate).getTime()) / (1000 * 60 * 60 * 24)))
      : 1;

    const totales = {
      totalGeneral,
      promedioDiario: totalGeneral / diasEnRango,
      cantidadTotal: egresosData.length,
    };

    return { egresos: egresosData, resumenPorTipo, totales };
  }

  async exportSuperExpensesToExcel(
    startDate?: string,
    endDate?: string,
    tipoEgresoId?: number,
    cajaNumero?: number,
  ): Promise<Buffer> {
    const data = await this.getSuperExpensesReport(startDate, endDate, tipoEgresoId, cajaNumero);
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Egresos y Gastos');

    worksheet.columns = [
      { header: 'ID', key: 'id', width: 10 },
      { header: 'Fecha', key: 'fecha', width: 15 },
      { header: 'Tipo de Egreso', key: 'tipoEgreso', width: 25 },
      { header: 'Descripción', key: 'descripcion', width: 35 },
      { header: 'Total', key: 'total', width: 15 },
      { header: 'Forma de Pago', key: 'formaPago', width: 20 },
      { header: 'Usuario', key: 'usuario', width: 25 },
      { header: 'Caja', key: 'cajaNumero', width: 10 },
    ];

    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFED7D31' },
    };

    data.egresos.forEach(egreso => {
      worksheet.addRow({
        ...egreso,
        fecha: new Date(egreso.fecha).toLocaleDateString(),
      });
    });

    const resumenSheet = workbook.addWorksheet('Resumen por Tipo');
    resumenSheet.columns = [
      { header: 'Tipo de Egreso', key: 'tipo', width: 30 },
      { header: 'Cantidad', key: 'cantidad', width: 15 },
      { header: 'Total', key: 'total', width: 15 },
    ];

    resumenSheet.getRow(1).font = { bold: true };
    resumenSheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF70AD47' },
    };

    data.resumenPorTipo.forEach(resumen => {
      resumenSheet.addRow(resumen);
    });

    resumenSheet.addRow({});
    resumenSheet.addRow({
      tipo: 'TOTAL GENERAL',
      cantidad: data.totales.cantidadTotal,
      total: data.totales.totalGeneral,
    });

    return await workbook.xlsx.writeBuffer() as Buffer;
  }

  async getBalanceSalesReport(
    startDate?: string,
    endDate?: string,
    cajaNumero?: number,
  ) {
    const whereConditionsVentas: any = { activo: true };
    const whereConditionsFlujos: any = { activo: true };

    if (startDate && endDate) {
      whereConditionsVentas.fecha = Between(new Date(startDate), new Date(endDate));
      whereConditionsFlujos.fecha = Between(new Date(startDate), new Date(endDate));
    }
    if (cajaNumero) {
      whereConditionsVentas.cajaNumero = cajaNumero;
      whereConditionsFlujos.cajaNumero = cajaNumero;
    }

    const ventas = await this.balanceSalesRepository.find({
      where: whereConditionsVentas,
      relations: ['telefonica', 'usuario'],
      order: { fecha: 'DESC' },
    });

    const flujos = await this.balanceFlowsRepository.find({
      where: whereConditionsFlujos,
      relations: ['telefonica'],
      order: { fecha: 'DESC' },
    });

    const ventasData = ventas.map(venta => ({
      id: venta.id,
      fecha: venta.fecha,
      telefonica: venta.telefonica?.nombre || 'N/A',
      cantidad: venta.cantidad,
      monto: Number(venta.monto),
      usuario: `${venta.usuario.nombre} ${venta.usuario.apellido}`,
      cajaNumero: venta.cajaNumero,
    }));

    const flujosData = flujos.map(flujo => ({
      id: flujo.id,
      fecha: flujo.fecha,
      telefonica: flujo.telefonica?.nombre || 'N/A',
      nombre: flujo.nombre,
      saldoVendido: Number(flujo.saldoVendido),
      saldoFinal: Number(flujo.saldoFinal),
    }));

    const totales = {
      totalVentas: ventasData.length,
      totalMontoVentas: ventasData.reduce((sum, v) => sum + v.monto, 0),
      totalSaldoVendido: flujosData.reduce((sum, f) => sum + f.saldoVendido, 0),
    };

    return { ventas: ventasData, flujos: flujosData, totales };
  }

  async exportBalanceSalesToExcel(
    startDate?: string,
    endDate?: string,
    cajaNumero?: number,
  ): Promise<Buffer> {
    const data = await this.getBalanceSalesReport(startDate, endDate, cajaNumero);
    const workbook = new ExcelJS.Workbook();
    
    const ventasSheet = workbook.addWorksheet('Ventas de Saldo');
    ventasSheet.columns = [
      { header: 'ID', key: 'id', width: 10 },
      { header: 'Fecha', key: 'fecha', width: 20 },
      { header: 'Telefónica', key: 'telefonica', width: 20 },
      { header: 'Cantidad', key: 'cantidad', width: 12 },
      { header: 'Monto', key: 'monto', width: 15 },
      { header: 'Usuario', key: 'usuario', width: 25 },
      { header: 'Caja', key: 'cajaNumero', width: 10 },
    ];

    ventasSheet.getRow(1).font = { bold: true };
    ventasSheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF5B9BD5' },
    };

    data.ventas.forEach(venta => {
      ventasSheet.addRow({
        ...venta,
        fecha: new Date(venta.fecha).toLocaleString(),
      });
    });

    const flujosSheet = workbook.addWorksheet('Flujos de Saldo');
    flujosSheet.columns = [
      { header: 'ID', key: 'id', width: 10 },
      { header: 'Fecha', key: 'fecha', width: 20 },
      { header: 'Telefónica', key: 'telefonica', width: 20 },
      { header: 'Nombre', key: 'nombre', width: 25 },
      { header: 'Saldo Vendido', key: 'saldoVendido', width: 15 },
      { header: 'Saldo Final', key: 'saldoFinal', width: 15 },
    ];

    flujosSheet.getRow(1).font = { bold: true };
    flujosSheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF70AD47' },
    };

    data.flujos.forEach(flujo => {
      flujosSheet.addRow({
        ...flujo,
        fecha: new Date(flujo.fecha).toLocaleString(),
      });
    });

    return await workbook.xlsx.writeBuffer() as Buffer;
  }

  // ==================== REPORTES DE OPERACIÓN AGENTE ====================

  async getAgentClosingsReport(
    startDate?: string,
    endDate?: string,
    proveedorId?: number,
  ) {
    const whereConditions: any = { estado: true };

    if (startDate && endDate) {
      whereConditions.fechaCierre = Between(new Date(startDate), new Date(endDate));
    }
    if (proveedorId) whereConditions.proveedorId = proveedorId;

    const cierres = await this.agentClosingsRepository.find({
      where: whereConditions,
      relations: ['proveedor'],
      order: { fechaCierre: 'DESC' },
    });

    const cierresData = cierres.map(cierre => ({
      id: cierre.id,
      fecha: cierre.fechaCierre,
      agente: cierre.proveedor?.nombre || 'N/A',
      saldoInicial: Number(cierre.saldoInicial),
      adicionalCta: Number(cierre.adicionalCta),
      resultadoFinal: Number(cierre.resultadoFinal),
      saldoFinal: Number(cierre.saldoFinal),
      diferencia: Number(cierre.diferencia),
    }));

    const totales = {
      totalSaldoInicial: cierresData.reduce((sum, c) => sum + c.saldoInicial, 0),
      totalSaldoFinal: cierresData.reduce((sum, c) => sum + c.saldoFinal, 0),
      totalDiferencias: cierresData.reduce((sum, c) => sum + Math.abs(c.diferencia), 0),
    };

    return { cierres: cierresData, totales };
  }

  async exportAgentClosingsToExcel(
    startDate?: string,
    endDate?: string,
    proveedorId?: number,
  ): Promise<Buffer> {
    const data = await this.getAgentClosingsReport(startDate, endDate, proveedorId);
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Cierres de Agentes');

    worksheet.columns = [
      { header: 'ID', key: 'id', width: 10 },
      { header: 'Fecha', key: 'fecha', width: 15 },
      { header: 'Agente', key: 'agente', width: 30 },
      { header: 'Saldo Inicial', key: 'saldoInicial', width: 15 },
      { header: 'Adicional Cta', key: 'adicionalCta', width: 15 },
      { header: 'Resultado Final', key: 'resultadoFinal', width: 18 },
      { header: 'Saldo Final', key: 'saldoFinal', width: 15 },
      { header: 'Diferencia', key: 'diferencia', width: 15 },
    ];

    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF9E480E' },
    };

    data.cierres.forEach(cierre => {
      worksheet.addRow({
        ...cierre,
        fecha: new Date(cierre.fecha).toLocaleDateString(),
      });
    });

    worksheet.addRow({});
    const totalRow = worksheet.addRow({
      id: '',
      fecha: '',
      agente: 'TOTALES:',
      saldoInicial: data.totales.totalSaldoInicial,
      adicionalCta: '',
      resultadoFinal: '',
      saldoFinal: data.totales.totalSaldoFinal,
      diferencia: data.totales.totalDiferencias,
    });
    totalRow.font = { bold: true };

    return await workbook.xlsx.writeBuffer() as Buffer;
  }

  async getAgentTransactionsReport(
    startDate?: string,
    endDate?: string,
    agenteId?: number,
    tipoTransaccionId?: number,
  ) {
    const whereConditions: any = { estado: true };

    if (startDate && endDate) {
      whereConditions.fecha = Between(new Date(startDate), new Date(endDate));
    }
    if (agenteId) whereConditions.agenteId = agenteId;
    if (tipoTransaccionId) whereConditions.tipoTransaccionId = tipoTransaccionId;

    const transactions = await this.transactionsRepository.find({
      where: whereConditions,
      relations: ['agente', 'tipoTransaccion'],
      order: { fecha: 'DESC' },
    });

    const transactionsData = transactions.map(tx => ({
      id: tx.id,
      fecha: tx.fecha,
      agente: tx.agente?.nombre || 'Efectivo',
      tipoTransaccion: tx.tipoTransaccion?.nombre || 'N/A',
      valor: Number(tx.valor),
      observaciones: tx.observaciones || '',
    }));

    const resumenPorAgente = new Map<string, number>();
    transactionsData.forEach(tx => {
      const current = resumenPorAgente.get(tx.agente) || 0;
      resumenPorAgente.set(tx.agente, current + tx.valor);
    });

    const resumenAgentes = Array.from(resumenPorAgente.entries()).map(([agente, total]) => ({
      agente,
      total,
    }));

    const totales = {
      totalTransacciones: transactionsData.length,
      totalValor: transactionsData.reduce((sum, tx) => sum + tx.valor, 0),
      promedio: transactionsData.length > 0 
        ? transactionsData.reduce((sum, tx) => sum + tx.valor, 0) / transactionsData.length
        : 0,
    };

    return { transacciones: transactionsData, resumenAgentes, totales };
  }

  async exportAgentTransactionsToExcel(
    startDate?: string,
    endDate?: string,
    agenteId?: number,
    tipoTransaccionId?: number,
  ): Promise<Buffer> {
    const data = await this.getAgentTransactionsReport(startDate, endDate, agenteId, tipoTransaccionId);
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Transacciones por Agente');

    worksheet.columns = [
      { header: 'ID', key: 'id', width: 10 },
      { header: 'Fecha', key: 'fecha', width: 20 },
      { header: 'Agente', key: 'agente', width: 25 },
      { header: 'Tipo Transacción', key: 'tipoTransaccion', width: 25 },
      { header: 'Valor', key: 'valor', width: 15 },
      { header: 'Observaciones', key: 'observaciones', width: 35 },
    ];

    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF70AD47' },
    };

    data.transacciones.forEach(tx => {
      worksheet.addRow({
        ...tx,
        fecha: new Date(tx.fecha).toLocaleString(),
      });
    });

    const resumenSheet = workbook.addWorksheet('Resumen por Agente');
    resumenSheet.columns = [
      { header: 'Agente', key: 'agente', width: 30 },
      { header: 'Total', key: 'total', width: 15 },
    ];

    resumenSheet.getRow(1).font = { bold: true };
    resumenSheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF4472C4' },
    };

    data.resumenAgentes.forEach(resumen => {
      resumenSheet.addRow(resumen);
    });

    return await workbook.xlsx.writeBuffer() as Buffer;
  }

  async getAgentConsolidatedReport(
    startDate?: string,
    endDate?: string,
  ) {
    const whereConditions: any = { estado: true };

    if (startDate && endDate) {
      whereConditions.fecha = Between(new Date(startDate), new Date(endDate));
    }

    const transactions = await this.transactionsRepository.find({
      where: whereConditions,
      relations: ['agente', 'tipoTransaccion'],
    });

    const agentTypeId = await this.getAgentTypeId();
    const agentes = await this.providersRepository.find({
      where: { tipoProveedorId: agentTypeId, activo: true },
    });

    const tiposTransaccion = await this.transactionTypesRepository.find();

    // Resumen general
    const agentesActivos = new Set(transactions.filter(tx => tx.agenteId).map(tx => tx.agenteId)).size;
    const totalTransacciones = transactions.length;
    const totalValor = transactions.reduce((sum, tx) => sum + Number(tx.valor), 0);

    // Por tipo de transacción
    const porTipo = tiposTransaccion.map(tipo => ({
      tipo: tipo.nombre,
      cantidad: transactions.filter(tx => tx.tipoTransaccionId === tipo.id).length,
      total: transactions
        .filter(tx => tx.tipoTransaccionId === tipo.id)
        .reduce((sum, tx) => sum + Number(tx.valor), 0),
    }));

    // Top agentes
    const topAgentes = agentes.map(agente => ({
      agente: agente.nombre,
      transacciones: transactions.filter(tx => tx.agenteId === agente.id).length,
      total: transactions
        .filter(tx => tx.agenteId === agente.id)
        .reduce((sum, tx) => sum + Number(tx.valor), 0),
    })).sort((a, b) => b.total - a.total).slice(0, 10);

    return {
      resumen: {
        agentesActivos,
        totalTransacciones,
        totalValor,
        promedioPorTransaccion: totalTransacciones > 0 ? totalValor / totalTransacciones : 0,
      },
      porTipo,
      topAgentes,
    };
  }

  async exportAgentConsolidatedToExcel(
    startDate?: string,
    endDate?: string,
  ): Promise<Buffer> {
    const data = await this.getAgentConsolidatedReport(startDate, endDate);
    const workbook = new ExcelJS.Workbook();
    
    // Hoja 1: Resumen General
    const resumenSheet = workbook.addWorksheet('Resumen General');
    resumenSheet.columns = [
      { header: 'Métrica', key: 'metrica', width: 30 },
      { header: 'Valor', key: 'valor', width: 20 },
    ];

    resumenSheet.getRow(1).font = { bold: true };
    resumenSheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF4472C4' },
    };

    resumenSheet.addRow({ metrica: 'Agentes Activos', valor: data.resumen.agentesActivos });
    resumenSheet.addRow({ metrica: 'Total Transacciones', valor: data.resumen.totalTransacciones });
    resumenSheet.addRow({ metrica: 'Valor Total', valor: data.resumen.totalValor });
    resumenSheet.addRow({ metrica: 'Promedio por Transacción', valor: data.resumen.promedioPorTransaccion });

    // Hoja 2: Por Tipo de Transacción
    const tipoSheet = workbook.addWorksheet('Por Tipo');
    tipoSheet.columns = [
      { header: 'Tipo Transacción', key: 'tipo', width: 30 },
      { header: 'Cantidad', key: 'cantidad', width: 15 },
      { header: 'Total', key: 'total', width: 15 },
    ];

    tipoSheet.getRow(1).font = { bold: true };
    tipoSheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF70AD47' },
    };

    data.porTipo.forEach(tipo => {
      tipoSheet.addRow(tipo);
    });

    // Hoja 3: Top Agentes
    const topSheet = workbook.addWorksheet('Top 10 Agentes');
    topSheet.columns = [
      { header: 'Agente', key: 'agente', width: 30 },
      { header: 'Transacciones', key: 'transacciones', width: 18 },
      { header: 'Total', key: 'total', width: 15 },
    ];

    topSheet.getRow(1).font = { bold: true };
    topSheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFED7D31' },
    };

    data.topAgentes.forEach(agente => {
      topSheet.addRow(agente);
    });

    return await workbook.xlsx.writeBuffer() as Buffer;
  }

=== FIN DEL CÓDIGO A COPIAR ===

4. Guarda el archivo
5. Compila el backend: npm run build
6. ¡Listo!
